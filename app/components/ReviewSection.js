'use client';

import React, { useState, useEffect, useCallback } from 'react';
import styles from './ReviewSection.module.css';
import Cookies from 'js-cookie';
import { useRouter } from 'next/router';
import { FaStar } from 'react-icons/fa';
import { FaEdit, FaTrash } from 'react-icons/fa';

const ReviewSection = ({ userId, onReviewAdded }) => {
  const [reviews, setReviews] = useState([]);
  const [newReview, setNewReview] = useState('');
  const [rating, setRating] = useState(0);
  const [hover, setHover] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [currentUser, setCurrentUser] = useState(null);
  const [selectedCategories, setSelectedCategories] = useState([]);
  const [categories, setCategories] = useState([]);
  const [successMessage, setSuccessMessage] = useState('');
  const [averageRating, setAverageRating] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [editingReviewId, setEditingReviewId] = useState(null);
  const [categoryStats, setCategoryStats] = useState({});
  const [tierlistCreated, setTierlistCreated] = useState(false);
  
  const router = useRouter();

  // Загрузка текущего пользователя из localStorage
  useEffect(() => {
    try {
      const userData = JSON.parse(localStorage.getItem('twitch_user') || '{}');
      setCurrentUser(userData);
    } catch (error) {
      console.error('Ошибка при загрузке данных пользователя:', error);
    }
  }, []);

  // Загрузка отзывов
  useEffect(() => {
    if (!userId) return;
    
    fetchReviews();
  }, [userId]);

  // Анализ категорий отзывов и создание тирлиста при необходимости
  useEffect(() => {
    if (reviews.length === 0) return;
    
    // Подсчитываем количество отзывов по каждой категории
    const stats = {};
    reviews.forEach(review => {
      if (review.categories && Array.isArray(review.categories)) {
        review.categories.forEach(category => {
          stats[category] = (stats[category] || 0) + 1;
        });
      }
    });
    
    setCategoryStats(stats);
    
    // Проверяем, есть ли категории с более чем 5 отзывами
    const popularCategories = Object.entries(stats)
      .filter(([_, count]) => count >= 5)
      .map(([category, _]) => category);
    
    // Если есть популярные категории и тирлист еще не создан, создаем его
    if (popularCategories.length > 0 && !tierlistCreated) {
      createTierlistFromCategories(popularCategories);
    }
  }, [reviews, tierlistCreated, userId]);

  // Функция для создания тирлиста на основе популярных категорий
  const createTierlistFromCategories = async (popularCategories) => {
    try {
      const accessToken = Cookies.get('twitch_access_token');
      if (!accessToken) return;
      
      // Получаем названия категорий
      const categoryNames = popularCategories.map(catId => {
        const category = categories.find(c => c.id === catId);
        return category ? category.name : catId;
      });
      
      // Создаем тирлист
      const response = await fetch('/api/tierlists/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`
        },
        body: JSON.stringify({
          title: `Топ качеств стримера ${currentUser?.display_name || 'пользователя'}`,
          category: 'streamer_qualities',
          items: categoryNames.map(name => ({ name, tier: 'S' })),
          userId: userId,
          isAutoGenerated: true,
          source: 'reviews'
        }),
      });
      
      if (response.ok) {
        setTierlistCreated(true);
        console.log('Автоматически создан тирлист на основе отзывов');
      }
    } catch (error) {
      console.error('Ошибка при создании тирлиста:', error);
    }
  };

  // Выносим функцию fetchReviews за пределы useEffect для возможности повторного использования
  const fetchReviews = async () => {
    try {
      setLoading(true);
      
      // Проверяем наличие токена
      const accessToken = Cookies.get('twitch_access_token');
      if (!accessToken) {
        console.warn('Отсутствует токен доступа для загрузки отзывов');
        // Продолжаем загрузку без токена, так как отзывы могут быть публичными
      }
      
      // Запрос к нашему API для получения отзывов
      const response = await fetch(`/api/reviews?targetUserId=${userId}`, {
        headers: accessToken ? {
          'Authorization': `Bearer ${accessToken}`
        } : {}
      });
      
      if (!response.ok) {
        if (response.status === 401) {
          console.warn('Требуется авторизация для загрузки отзывов');
          setError('Для просмотра отзывов необходимо авторизоваться');
        } else {
          throw new Error('Ошибка загрузки отзывов');
        }
      } else {
        const reviewsData = await response.json();
        console.log('Загружены отзывы:', reviewsData);
        
        setReviews(reviewsData);
        
        // Рассчитываем средний рейтинг
        if (reviewsData.length > 0) {
          const sum = reviewsData.reduce((acc, review) => acc + review.rating, 0);
          setAverageRating((sum / reviewsData.length).toFixed(1));
        }
      }
    } catch (error) {
      console.error('Ошибка при загрузке отзывов:', error);
      setError('Не удалось загрузить отзывы. Пожалуйста, попробуйте позже.');
    } finally {
      setLoading(false);
    }
  };

  // Начать редактирование отзыва
  const startEditingReview = (reviewId) => {
    const reviewToEdit = reviews.find(r => r.id === reviewId);
    if (reviewToEdit) {
      setEditingReviewId(reviewId);
      setNewReview(reviewToEdit.text);
      setRating(reviewToEdit.rating);
      setSelectedCategories(reviewToEdit.categories || []);
    }
  };

  // Отменить редактирование
  const cancelEditing = () => {
    setEditingReviewId(null);
    setNewReview('');
    setRating(0);
    setSelectedCategories([]);
  };

  // Обработка отправки формы
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Проверка авторизации
    const accessToken = Cookies.get('twitch_access_token');
    if (!accessToken || !currentUser) {
      setError('Необходимо авторизоваться для отправки отзыва');
      return;
    }
    
    // Проверка наличия текста отзыва
    if (!newReview.trim()) {
      setError('Отзыв не может быть пустым');
      return;
    }
    
    // Проверка рейтинга
    if (rating === 0) {
      setError('Пожалуйста, поставьте оценку');
      return;
    }
    
    // Проверка, что пользователь не оставляет отзыв самому себе
    if (currentUser.id === userId) {
      setError('Вы не можете оставить отзыв самому себе');
      return;
    }
    
    // Проверка, что пользователь не оставлял отзыв ранее (только для новых отзывов)
    if (!editingReviewId) {
      const hasReviewed = reviews.some(review => review.reviewerId === currentUser.id);
      if (hasReviewed) {
        setError('Вы уже оставили отзыв для этого пользователя');
        return;
      }
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const reviewData = {
        text: newReview,
        rating,
        categories: selectedCategories
      };
      
      let response;
      
      if (editingReviewId) {
        // Обновление существующего отзыва
        response = await fetch(`/api/reviews/update/${editingReviewId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          },
          body: JSON.stringify(reviewData)
        });
      } else {
        // Создание нового отзыва
        reviewData.targetUserId = userId; // ID пользователя, которому оставляют отзыв
        
        response = await fetch('/api/reviews/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          },
          body: JSON.stringify(reviewData)
        });
      }
      
      if (!response.ok) {
        throw new Error('Не удалось сохранить отзыв');
      }
      
      const data = await response.json();
      
      if (editingReviewId) {
        // Обновление списка отзывов после редактирования
        setReviews(reviews.map(review => 
          review.id === editingReviewId ? { ...data, reviewerId: currentUser.id } : review
        ));
        setSuccessMessage('Отзыв успешно обновлен!');
        setEditingReviewId(null);
      } else {
        // Добавление нового отзыва в список
        setReviews([...reviews, { ...data, reviewerId: currentUser.id }]);
        setSuccessMessage('Отзыв успешно добавлен!');
      }
      
      // Сброс формы
      setNewReview('');
      setRating(0);
      setSelectedCategories([]);
      
      // Пересчет среднего рейтинга
      const updatedReviews = editingReviewId 
        ? reviews.map(review => review.id === editingReviewId ? { ...data, reviewerId: currentUser.id } : review)
        : [...reviews, { ...data, reviewerId: currentUser.id }];
      
      const totalRating = updatedReviews.reduce((sum, review) => sum + review.rating, 0);
      setAverageRating((totalRating / updatedReviews.length).toFixed(1));
      
      // Скрыть сообщение через 5 секунд
      setTimeout(() => {
        setSuccessMessage('');
      }, 5000);
      
      // Вызываем колбэк, если он предоставлен
      if (typeof onReviewAdded === 'function') {
        onReviewAdded();
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  // Удаление отзыва
  const handleDeleteReview = async (reviewId) => {
    if (!confirm('Вы уверены, что хотите удалить этот отзыв?')) {
      return;
    }
    
    const accessToken = Cookies.get('twitch_access_token');
    if (!accessToken) {
      setError('Необходимо авторизоваться для удаления отзыва');
      return;
    }
    
    try {
      const response = await fetch(`/api/reviews/delete/${reviewId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${accessToken}`
        }
      });
      
      if (!response.ok) {
        throw new Error('Не удалось удалить отзыв');
      }
      
      // Удаление отзыва из списка
      const updatedReviews = reviews.filter(review => review.id !== reviewId);
      setReviews(updatedReviews);
      
      // Пересчет среднего рейтинга
      if (updatedReviews.length > 0) {
        const totalRating = updatedReviews.reduce((sum, review) => sum + review.rating, 0);
        setAverageRating((totalRating / updatedReviews.length).toFixed(1));
      } else {
        setAverageRating(0);
      }
      
      setSuccessMessage('Отзыв успешно удален!');
      
      // Скрыть сообщение через 5 секунд
      setTimeout(() => {
        setSuccessMessage('');
      }, 5000);
      
      // Вызываем колбэк, если он предоставлен
      if (typeof onReviewAdded === 'function') {
        onReviewAdded();
      }
    } catch (err) {
      setError(err.message);
    }
  };

  // Переключение категории
  const toggleCategory = (category) => {
    if (selectedCategories.includes(category)) {
      setSelectedCategories(selectedCategories.filter(c => c !== category));
    } else {
      setSelectedCategories([...selectedCategories, category]);
    }
  };

  // Форматирование даты на русском языке
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('ru-RU', {
      day: 'numeric',
      month: 'long',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Рендеринг звездочек для оценки
  const renderStarRating = (value) => {
    return (
      <div className={styles.stars}>
        {[...Array(5)].map((_, i) => {
          const ratingValue = i + 1;
          return (
            <label key={i}>
              <input
                type="radio"
                name="rating"
                value={ratingValue}
                onClick={() => setRating(ratingValue)}
                style={{ display: 'none' }}
              />
              <FaStar
                className={styles.star}
                color={ratingValue <= (hover || rating) ? "#ffc107" : "#e4e5e9"}
                size={24}
                onMouseEnter={() => setHover(ratingValue)}
                onMouseLeave={() => setHover(0)}
              />
            </label>
          );
        })}
      </div>
    );
  };

  // Рендеринг звездочек для отображения (без интерактивности)
  const renderStaticStarRating = (value) => {
    return (
      <div className={styles.stars}>
        {[...Array(5)].map((_, i) => {
          const ratingValue = i + 1;
          return (
            <FaStar
              key={i}
              className={styles.star}
              color={ratingValue <= value ? "#ffc107" : "#e4e5e9"}
              size={16}
            />
          );
        })}
      </div>
    );
  };

  // Рендеринг популярных категорий
  const renderPopularCategories = () => {
    if (Object.keys(categoryStats).length === 0) {
      return null;
    }
    
    return (
      <div className={styles.categoryStats}>
        <h3>Популярные категории в отзывах</h3>
        <div className={styles.categoryTags}>
          {Object.entries(categoryStats)
            .sort((a, b) => b[1] - a[1]) // Сортировка по количеству отзывов
            .map(([category, count]) => (
              <div key={category} className={styles.popularCategory}>
                <span className={styles.categoryName}>{category}</span>
                <span className={styles.categoryCount}>{count}</span>
              </div>
            ))}
        </div>
      </div>
    );
  };

  // Рендеринг формы отзыва
  const renderReviewForm = () => {
    if (!currentUser) {
      return (
        <div className={styles.loginPrompt}>
          <p>Войдите, чтобы оставить отзыв</p>
          <button onClick={() => router.push('/login')} className={styles.loginButton}>
            Войти
          </button>
        </div>
      );
    }

    if (currentUser.id === userId) {
      return null; // Не показывать форму, если пользователь просматривает свой профиль
    }

    const hasReviewed = reviews.some(review => review.reviewerId === currentUser.id);
    if (hasReviewed && !editingReviewId) {
      return null; // Не показывать форму, если пользователь уже оставил отзыв
    }

    return (
      <form onSubmit={handleSubmit} className={styles.reviewForm}>
        <h3>{editingReviewId ? 'Редактировать отзыв' : 'Оставить отзыв'}</h3>
        
        <div className={styles.ratingContainer}>
          <p>Ваша оценка:</p>
          {renderStarRating(rating)}
        </div>
        
        <div className={styles.categoriesContainer}>
          <p>Выберите категории:</p>
          <div className={styles.categoriesSelection}>
            {categories.map(category => (
              <button
                key={category}
                type="button"
                className={`${styles.categoryButton} ${
                  selectedCategories.includes(category) ? styles.selected : ''
                }`}
                onClick={() => toggleCategory(category)}
              >
                {category}
              </button>
            ))}
          </div>
        </div>
        
        <textarea
          value={newReview}
          onChange={(e) => setNewReview(e.target.value)}
          placeholder="Напишите ваш отзыв..."
          className={styles.reviewInput}
          rows={4}
        />
        
        <div className={styles.formActions}>
          {editingReviewId && (
            <button
              type="button"
              onClick={cancelEditing}
              className={styles.cancelButton}
              disabled={isSubmitting}
            >
              Отмена
            </button>
          )}
          
          <button
            type="submit"
            className={styles.submitButton}
            disabled={isSubmitting}
          >
            {isSubmitting
              ? 'Отправка...'
              : editingReviewId
                ? 'Сохранить изменения'
                : 'Отправить отзыв'}
          </button>
        </div>
      </form>
    );
  };

  if (loading) {
    return <div className={styles.loading}>Загрузка отзывов...</div>;
  }

  return (
    <div className={styles.reviewSection}>
      <h2>Отзывы {reviews.length > 0 && `(${reviews.length})`}</h2>
      
      {averageRating > 0 && (
        <div className={styles.averageRating}>
          <span>Средняя оценка: {averageRating}</span>
          {renderStaticStarRating(parseFloat(averageRating))}
        </div>
      )}
      
      {error && <div className={styles.error}>{error}</div>}
      {successMessage && <div className={styles.success}>{successMessage}</div>}
      
      {renderPopularCategories()}
      
      {renderReviewForm()}
      
      <div className={styles.reviewsList}>
        {reviews.length === 0 ? (
          <p className={styles.noReviews}>Отзывов пока нет</p>
        ) : (
          reviews.map((review) => (
            <div key={review.id} className={styles.reviewItem}>
              <div className={styles.reviewHeader}>
                <div className={styles.authorInfo}>
                  <img
                    src={review.authorImage || '/images/default-avatar.png'}
                    alt={review.authorName}
                    className={styles.authorAvatar}
                  />
                  <span className={styles.authorName}>{review.authorName}</span>
                </div>
                <div className={styles.reviewRating}>
                  {renderStaticStarRating(review.rating)}
                  <span className={styles.ratingValue}>{review.rating}/5</span>
                </div>
              </div>
              
              {review.categories && review.categories.length > 0 && (
                <div className={styles.reviewCategories}>
                  {review.categories.map(category => (
                    <span key={category} className={styles.reviewCategory}>
                      {category}
                    </span>
                  ))}
                </div>
              )}
              
              <p className={styles.reviewText}>{review.text || review.comment}</p>
              <div className={styles.reviewFooter}>
                <span className={styles.reviewDate}>{formatDate(review.createdAt)}</span>
                
                {currentUser && currentUser.id === review.reviewerId && (
                  <div className={styles.reviewActions}>
                    <button
                      onClick={() => startEditingReview(review.id)}
                      className={styles.editButton}
                    >
                      <FaEdit /> Редактировать
                    </button>
                    <button
                      onClick={() => handleDeleteReview(review.id)}
                      className={styles.deleteButton}
                    >
                      <FaTrash /> Удалить
                    </button>
                  </div>
                )}
              </div>
            </div>
          ))
        )}
      </div>
    </div>
  );
};

// Вспомогательная функция для склонения слов
function getDeclension(number, words) {
  const cases = [2, 0, 1, 1, 1, 2];
  return words[(number % 100 > 4 && number % 100 < 20) ? 2 : cases[(number % 10 < 5) ? number % 10 : 5]];
}

// Устанавливаем defaultProps для компонента
ReviewSection.defaultProps = {
  onReviewAdded: () => {} // Пустая функция по умолчанию
};

export default ReviewSection; 